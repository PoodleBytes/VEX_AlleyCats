#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    Arm_Angle,      sensorPotentiometer)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port2,           L_Front,       tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port3,           R_Front,       tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_2)
#pragma config(Motor,  port4,           L_Arm,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           L_Rear,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           R_Rear,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           R_Arm,         tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//VEX COMPETITION INCLUDES
#pragma platform(VEX2)//VEX cortex platform
//#pragma competitionControl(Competition)	// Select Download method as "competition"
#include "Vex_Competition_Includes.c"	//do not modify

void pre_auton()	//You must return from this function or the autonomous and usercontrol tasks will not be started.
{
  bStopTasksBetweenModes = true;
}

/*				VARIABLES 	*/
//drive()
int L_POWER = 0;								//left drive power in drive()
int R_POWER = 0;								//right drive power in drive()
int MAX_POWER = 100;						//maximum power to motor - 127 is max
float DRIVE_SENSITIVITY = 0.5;		//coefficient = decrease joystick sensitivity
int DEADBAND = 15;							//Joystick seldom 0 when off so this is the value to ignore joystick 'noise' below
int ARM_POWER = 0;							//power to apply to arm if needed
float ARM_SENSITIVITY = 0.8;		//slow arm movements

//xxxCap() variables - flipArm OK 10-22 (250,50,150,50)
int flipArmTime = 250;		//time lift arm before drive foward
int flipArmSpeed = 50;		//power to lift arm
int flipDriveTime = 150;	//time before driving foward
int flipDriveSpeed = 50;	//drive power
int armMax = 2200;
int armCapHigh = 2000;		// TBD - value of Arm_Angle potentioneter for placing high caps
int armCapLow = 1500;			//TBD - value of Arm_Angle potentioneter for placing high caps

// autonomous driving variables
int pause1 = 300;
int iBrake = 50;

/*			FUNCTIONS		*/

//	drive to distance using encoder ticks
void eDrive(int l, int r, int e){
	resetMotorEncoder(R_Front);
	resetMotorEncoder(L_Front);
	wait1Msec(pause1);
	while(abs(getMotorEncoder(R_Front)) < e)  {
		motor[R_Rear] = motor[R_Front]=r;
		motor[L_Rear] = motor[L_Front]=l;}
	wait1Msec(iBrake);
	motor[R_Rear] = motor[R_Front]=0;
	motor[L_Rear] = motor[L_Front]=0;
	wait1Msec(iBrake);
	motor[R_Rear] = motor[R_Front]=r *-.5;
	motor[L_Rear] = motor[L_Front]=l * -.5;
	wait1Msec(iBrake);
	motor[R_Rear] = motor[R_Front]=0;
	motor[L_Rear] = motor[L_Front]=0;
}//end eDrive

//timed drive
void tDrive(int l, int r, int t){
	wait1Msec(pause1);
	motor[R_Rear] = motor[R_Front]=r;
	motor[L_Rear] = motor[L_Front]=l;
	wait1Msec(t);
	motor[R_Rear] = motor[R_Front]=0;
	motor[L_Rear] = motor[L_Front]=0;
	wait1Msec(iBrake);
	motor[R_Rear] = motor[R_Front]=r *-.5;
	motor[L_Rear] = motor[L_Front]=l * -.5;
	wait1Msec(iBrake);
	motor[R_Rear] = motor[R_Front]=0;
	motor[L_Rear] = motor[L_Front]=0;
}//end tDrive

//drive control
task drive(){
	while(true){
		// calculate arcade drive motor[ power
		if(abs((vexRT[Ch2] + vexRT[Ch1]))>DEADBAND){
			L_POWER =(vexRT[Ch2] + vexRT[Ch1])* DRIVE_SENSITIVITY;
			R_POWER =(vexRT[Ch2] - vexRT[Ch1]) * DRIVE_SENSITIVITY;
		}
		else {
			L_POWER = 0;
			R_POWER = 0;
		}

		// limit motor power to MAX_POWER
		if( abs(R_POWER) > MAX_POWER)
			R_POWER = sgn(R_POWER) * MAX_POWER;
		if( abs(L_POWER) > MAX_POWER )
			L_POWER = sgn(L_POWER) * MAX_POWER;

		motor[L_Front]= motor[L_Rear]=L_POWER;
		motor[R_Front]= motor[R_Rear]=R_POWER;
	}//end while
}//end drive

task arm(){
	while(true){
		//ARM HEIGHT
		if(abs(vexRT[Ch3])> DEADBAND && SensorValue(Arm_Angle) < armMax)
		{
			motor[L_Arm]=motor[R_Arm]=vexRT[Ch3] * ARM_SENSITIVITY;
		}
		else
		{
			motor[L_Arm]=motor[R_Arm]=ARM_POWER;
		}

		if(SensorValue(Arm_Angle) > armCapLow / 4){ //arm is raised (3700 is full down, ~1700 up)
				ARM_POWER = 10;
			}
			else {
				ARM_POWER = 0;
			}
	}//end while
}//end arm

	//flip cap
void flipCap(void){
		//stop tasks that may interfere with actions
		stopTask(arm);
		stopTask(drive);
		//perform flip by..
		motor[L_Arm]=motor[R_Arm]=flipArmSpeed;	//lift claw
		wait1Msec(flipArmTime);		//wait
		motor[L_Front]= motor[L_Rear]=flipDriveSpeed;	//drive forward to push cap
		motor[R_Front]= motor[R_Rear]=flipDriveSpeed;
		wait1Msec(flipDriveTime);	//wait
		motor[L_Front]= motor[L_Rear]=0;	//stop
		motor[R_Front]= motor[R_Rear]=0;
		motor[L_Arm]=motor[R_Arm]=0;
		// lower claw TBD (added 10-23)
		motor[L_Arm]=motor[R_Arm]=flipArmSpeed * -1 ;	//lower claw
		wait1Msec((flipArmTime + flipDriveTime) * 0.8);	//wait - probably too long
		motor[L_Arm]=motor[R_Arm]=0;
		//re-start tasks
		startTask(arm);
		startTask(drive);
	}

//position arm for placing cap on 36" post
task liftCap(){
	while(true){
		if(vexRT[Btn7U]==1){
			stopTask(arm);
			while(SensorValue(Arm_Angle) < armCapHigh){
				motor[L_Arm]=motor[R_Arm]=40;}	//lift claw
			motor[L_Arm]=motor[R_Arm]=0;
			startTask(arm);
		}//lift claw

		if(vexRT[Btn7D]==1){
			stopTask(arm);
			while(SensorValue(Arm_Angle) < armCapLow){
				motor[L_Arm]=motor[R_Arm]=40;}	//lift claw
			motor[L_Arm]=motor[R_Arm]=0;
			startTask(arm);
		}//end btn 7d
	}//end while
}//end liftCap



task autonomous()
{
	tDrive(0,0,0); //timed driving distance: Left power, Right power, Time (ms)
	eDrive(0,0,0);//encoder driving distance: Left power, Right power, Time (ms)
}

task usercontrol()
{
	startTask(drive);
	startTask(arm);
	startTask(liftCap);
	while (true){
		if(vexRT[Btn7L]==1){flipCap();}

		//micro-drive
		if(vexRT[Btn8U]==1){//straight
			stopTask(drive);
			tDrive(30,30,150);
			startTask(drive);}
		if(vexRT[Btn8D]==1){	//reverse
			stopTask(drive);
			tDrive(-30,-30,150);
			startTask(drive);}
		if(vexRT[Btn8L]==1){	//left
			stopTask(drive);
			tDrive(30,30,150);
			startTask(drive);}
		if(vexRT[Btn8R]==1){	//right
			stopTask(drive);
			tDrive(30,-30,150);
			startTask(drive);}
	}//end while
}//end main
