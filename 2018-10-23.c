#pragma config(Sensor, in1,    Arm_Angle,      sensorPotentiometer)
#pragma config(Motor,  port2,           L_Front,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           R_Front,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           L_Arm,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           L_Rear,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           R_Rear,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           R_Arm,         tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//



//VARIABLES
int L_POWER = 0;								//left drive power in drive()
int R_POWER = 0;								//right drive power in drive()
int MAX_POWER = 100;						//maximun power to motor - 127 is max
float DRIVE_SENSITIVITY = 0.8;		//coefficient = decrease joystick sensitivity
int DEADBAND = 15;							//Joystick seldom 0 when off so this is the value to ignore joystick 'noise' below
int ARM_POWER = 0;							//power to apply to arm if needed
float ARM_SENSITIVITY = 0.8;		//slow arm movements

//flip Cap variables
int flipArmTime = 250;		//time before driving foward
int flipArmSpeed = 50;		//power to lift arm
int flipDriveTime = 150;
int flipDriveSpeed = 50;



//drive control
task drive(){
	while(true){
		// calculate arcade drive motor[ power
		if(abs((vexRT[Ch2] + vexRT[Ch1]))>DEADBAND){
			L_POWER =(vexRT[Ch2] + vexRT[Ch1])* DRIVE_SENSITIVITY;
			R_POWER =(vexRT[Ch2] - vexRT[Ch1]) * DRIVE_SENSITIVITY;
		}
		else {
			L_POWER = 0;
			R_POWER = 0;
		}

		// limit motor power to MAX_POWER
		if( abs(R_POWER) > MAX_POWER)
			R_POWER = sgn(R_POWER) * MAX_POWER;
		if( abs(L_POWER) > MAX_POWER )
			L_POWER = sgn(L_POWER) * MAX_POWER;

		motor[L_Front]= motor[L_Rear]=L_POWER;
		motor[R_Front]= motor[R_Rear]=R_POWER;
	}//end while

}//end drive
	task arm(){
		//ARM HEIGHT
		if(abs(vexRT[Ch3])> DEADBAND)
		{
			motor[L_Arm]=motor[R_Arm]=vexRT[Ch3] * ARM_SENSITIVITY;
		}
		else
		{
			motor[L_Arm]=motor[R_Arm]=ARM_POWER;
		}

		if(SensorValue(Arm_Angle) < 3500){ //arm is raised (3700 is full down, ~1700 up)
				ARM_POWER = 10;
			}
			else {
				ARM_POWER = 0;
			}
	}//end arm

	//flip cap
void flipCap(void){
			stopTask(arm);
			stopTask(drive);
			motor[L_Arm]=motor[R_Arm]=flipArmSpeed;
			wait1Msec(flipArmTime);
			motor[L_Front]= motor[L_Rear]=flipDriveSpeed;
			motor[R_Front]= motor[R_Rear]=flipDriveSpeed;
			wait1Msec(flipDriveTime);
			motor[L_Front]= motor[L_Rear]=0;
			motor[R_Front]= motor[R_Rear]=0;
			motor[L_Arm]=motor[R_Arm]=0;
			startTask(arm);
			startTask(drive);
	}

task main()
{
  while(1 == 1)
  {
		startTask(drive);
		startTask(arm);
			if(vexRT[Btn7L]==1){flipCap();}
  }//end while
}//end main
