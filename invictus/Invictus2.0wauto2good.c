#pragma config(Sensor, in1,    arm_angle,      sensorPotentiometer)
#pragma config(Sensor, in2,    cap_flip_angle, sensorPotentiometer)
#pragma config(Sensor, in3,    red_blue_sw,    sensorPotentiometer)
#pragma config(Sensor, in4,    robot_lift_angle, sensorPotentiometer)
#pragma config(Motor,  port1,           drive_left_rear, tmotorVex393HighSpeed_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           drive_right_front, tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           lift_left,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           lift_right,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           cap_flip_left, tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           cap_flip_right, tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           drive_left_front, tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port8,           robot_lift,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           drive_right_rear, tmotorVex393HighSpeed_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/

// This code is for the VEX cortex platform
#pragma platform(VEX2)


//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/

void pre_auton()
{
	slaveMotor(lift_right, lift_left);
	slaveMotor(cap_flip_right, cap_flip_left);
	slaveMotor(drive_left_front, drive_left_rear);
	slaveMotor(drive_right_front, drive_right_rear);
	bStopTasksBetweenModes = true;

}
/*      VARIABLES     */
//drive variables//
int L_POWER = 100;								//left drive power in drive()
int R_POWER = 100;								//right drive power in drive()
int MAX_POWER = 100;						  //maximum power to motor - 127 is max
float DRIVE_SENSITIVITY = 0.5;		//coefficient = decrease joystick sensitivity
int DEADBAND = 25;                //Joystick seldom 0 when off so this is the value to ignore joystick noise

//arm variables //
int ARM_POWER = 0;							//power to apply to arm if needed
float ARM_SENSITIVITY = 0.6;		//slow arm movements
int HOLD_ARM = 20;              //arm hold in the air motor power
int ARM_MAX = 1800;			      	//maximum height of arm (1600 max top
int ARM_CAP_HIGH = 1800;	    	// value of Arm_Angle potentioneter for placing high caps
int ARM_CAP_LOW = 2000;         // value of Arm_Angle potentioneter for placing low caps

//robot lift variables //
int ROBOT_LIFT_DOWN = 3700;     //robot lift down max
int ROBOT_LIFT_UP = 800;        //robot lift up position

//one button cap flip variables //
int FLIP_ARM_TIME = 350;		//time lift arm before drive foward
int FLIP_ARM_SPEED = -60;		//power to lift arm
int FLIP_DRIVE_TIME = 200;	//time before driving foward
int FLIP_DRIVE_SPEED = 90;	//drive power
int CAP_FLIP_DOWN = 2500;   // lowered value of cap flip frame
int HOLD_CAP_FLIP = -5;

// autonomous tDrive coast and braking variables //
int DRIVE_PAUSE = 200;
int BRAKE_TIME = 50;


// DRIVE CONTROL
task drive(){
	while(true){
		// calculate arcade drive motor power
		if(abs((vexRT[Ch2] + vexRT[Ch1]))>DEADBAND){
			L_POWER =(vexRT[Ch2] + vexRT[Ch1])* DRIVE_SENSITIVITY;
			R_POWER =(vexRT[Ch2] - vexRT[Ch1]) * DRIVE_SENSITIVITY;
		}
		else {
			L_POWER = 0;
			R_POWER = 0;
		}

		// limit motor power to MAX_POWER
		if(abs(R_POWER) > MAX_POWER)
			R_POWER = sgn(R_POWER) * MAX_POWER;
		if(abs(L_POWER) > MAX_POWER )
			L_POWER = sgn(L_POWER) * MAX_POWER;

		motor[drive_left_front]= L_POWER;
		motor[drive_right_front]=R_POWER;
		motor[drive_left_rear]= L_POWER;
		motor[drive_right_rear]= R_POWER;
	}//end while
}//end drive

//ARM CONTROL//
task arm(){
	while(true){
		if(vexRT[Ch3]> DEADBAND && SensorValue(arm_angle) > ARM_MAX){//limit height
			motor[lift_left]=vexRT[Ch3] * ARM_SENSITIVITY;
		}
		else if(vexRT[Ch3] < (DEADBAND * -2) && SensorValue(arm_angle) > ARM_MAX){
			motor[lift_left]=vexRT[Ch3] * ARM_SENSITIVITY;
		}
		else if(vexRT[Ch3] < (DEADBAND * -2) && SensorValue(arm_angle) < ARM_MAX){
			motor[lift_left]=vexRT[Ch3] * ARM_SENSITIVITY;}

		else{
			if(SensorValue(arm_angle) < 2600){
				motor[lift_left]=HOLD_ARM;//add arm lift hold power if arm is up
				motor[cap_flip_left] = HOLD_CAP_FLIP;}//add cap flip hold power if arm is up
			else{
				motor[lift_left]=ARM_POWER;
				motor[cap_flip_left]=0;}


		}




}//end while
}//end arm

//ONE BUTTON CAP FLIP//
task autoFC(){
	while(true){


		if(vexRT[Btn7L]==1){
			//stop tasks that may interfere with actions
			stopTask(drive);
			stopTask(arm);
			//perform flip by..
			motor[lift_left]=-20;
			motor[drive_left_front]= FLIP_DRIVE_SPEED;	//drive forward to push cap
			motor[drive_right_front]=FLIP_DRIVE_SPEED;
			motor[cap_flip_left]=FLIP_ARM_SPEED;	//lift claw
			wait1Msec(FLIP_ARM_TIME);
			wait1Msec(FLIP_DRIVE_TIME);//wait
			wait1Msec(FLIP_DRIVE_SPEED);


			motor[drive_left_front]= 0;	//stop
			motor[drive_right_front]=0;
			motor[cap_flip_left]=0;
			motor[lift_left]=0;
			wait1Msec(FLIP_ARM_TIME);		//wait
			wait1Msec(FLIP_DRIVE_TIME);	//
			wait1Msec(FLIP_DRIVE_SPEED);


			motor[drive_left_front]= FLIP_DRIVE_SPEED * -.5; //reverse and lower claw
			motor[drive_right_front]= FLIP_DRIVE_SPEED * -.5;
			motor[cap_flip_left]=FLIP_ARM_SPEED * -.6;
			wait1Msec(FLIP_ARM_TIME);		//wait
			wait1Msec(FLIP_DRIVE_TIME);
			wait1Msec(FLIP_DRIVE_SPEED);
			motor[drive_left_front]=0;
			motor[drive_right_front] = 0;
			motor[cap_flip_left]=0;

			//re-start tasks
			startTask(arm);
			startTask(drive);}


	}//end if
}//end autoFC


//ONE BUTTON LOW AND HIGH CAP LIFT//
task poleLift(){
	while(true){

		//lift cap for 36" post
		if(vexRT[Btn5U]==1){
			stopTask(arm);
			while(SensorValue(arm_angle) > ARM_CAP_HIGH){
				motor[lift_left]=80;}//lift arm up to high post
			startTask(arm);
				}// end btn 5U

		//lift cap for 24" post
		if(vexRT[Btn5D]==1){
			stopTask(arm);
			while(SensorValue(arm_angle) > ARM_CAP_LOW){
				motor[lift_left]=80;}//lift arm to low post
				startTask(arm);
			}//end 5D
	}//end while
}//end poleLift



task FlipFrame(){
	while (true){
		if(vexRT[Btn6U]==1)
		{
			stopTask(arm);
			if(SensorValue(arm_angle)>ARM_CAP_LOW)
				{
				motor[cap_flip_left]=-90;
				}//lift frame
			else
				{
				motor[cap_flip_left]=-30;
				}//lift frame
			}
		else
		{
			wait1Msec(100);
			motor[cap_flip_left]= 0;}
			startTask(arm);
		}

		}	//end 6U

		//down sets to neutral scoop position
		if(vexRT[Btn6D]==1){
			stopTask(arm);
			while(SensorValue(cap_flip_angle) > CAP_FLIP_DOWN){
				motor[cap_flip_left]=40;	//lower frame
				motor[lift_left]=-10;}
			wait1Msec(90);
			motor[cap_flip_left]=0;
			motor[lift_left]=0;
			startTask(arm);
		}
	}//end 6D
}//end Flipper




//TIMED DRIVE autonomous drive program //
void tDrive(int l, int r, int t){
	wait1Msec(DRIVE_PAUSE);
	motor[drive_right_front]=r;
	motor[drive_left_front]=l;
	motor[drive_left_rear]=l;
	motor[drive_right_rear]=r;
	wait1Msec(t);
	motor[drive_right_front]=0;
	motor[drive_left_front]=0;
	motor[drive_left_rear]=0;
	motor[drive_right_rear]=0;
	wait1Msec(BRAKE_TIME);
	motor[drive_right_front]=r *-7;
	motor[drive_left_front]=l * -1;
	motor[drive_left_rear]=1 *-1;
	motor[drive_right_rear]=r *-.7;
	wait1Msec(BRAKE_TIME);
	motor[drive_right_front]=0;
	motor[drive_left_front]=0;
	motor[drive_left_rear]=0;
	motor[drive_right_rear]=0;
}//end tDrive






/*void AutoA(int direction){//Comp Auto near flags 2 Point Red anb Blue
tDrive(100,100,1300);//drive to first cap
motor[cap_flip_left] = -50;//pick up cap
wait1Msec(700);
motor[cap_flip_left]=0;
tDrive(-70,-40,300);//small reverse
motor[cap_flip_left]=50;//put down cap
wait1Msec(400);
motor[cap_flip_left]=0;
tDrive(-70,-70,1250);//reverse to flag
tDrive(-100 *direction ,100 * direction, 300);//turn to flag
tDrive(-100,-100,1500);//reverse to toggle flag
tDrive(100,100,300);//pull forward
}*/



void autoB(int direction){//Comp Auto away flags 4 Point Red and Blue
	tDrive(100,100,1200);//drive to cap
	motor[cap_flip_left] = -50;//pick up cap
	wait1Msec(300);
	motor[cap_flip_left]=20;//set down cap
	wait1Msec(75);
	tDrive(-50,-40,525);// reverse
	wait1Msec(100);
	tDrive(-100 * direction,100 * direction,455);//turn to reverse for running start
	motor[cap_flip_left]=-50;	//lift frame cap motorwait1Msec(100);ark
	wait1Msec(300);
	motor[cap_flip_left]=0;
	tDrive(-50 * direction,-70* direction,400);//reverse for running start
	tDrive(127,127, 1800);//drive onto blue/red platform

}

/*void autoB(int direction){//Skills Auto away flags 8 Point Red and Blue
	tDrive(70,70,1270);//drive to first cap
	motor[cap_flip_left] = -90; //flip cap
	wait1Msec(600);
	motor[cap_flip_left]=0;
	tDrive(-90,-70,450);//small reverse
	tDrive(-100 * direction,100 * direction,350);//turn to second cap
	motor[cap_flip_left]=40;//lower flipper
	wait1Msec(500);
	motor[cap_flip_left]=0;
	tDrive(-100,-100,460);//drive to second cap
	tDrive(100*direction,-100*direction,360);//turn to second cap
	tDrive(50,50,690);//drive forward to flip
	motor[cap_flip_left]=-90;//flip cap
	wait1Msec(500);
	motor[cap_flip_left]=0;
  tDrive(-70,-50,180);//small reverse
	tDrive(-100*direction,100*direction,360);//turn towards blue platform
	tDrive(127,127, 1900);//drive up on blue platform
	/*tDrive(80*direction,-80*direction,425);//turn on platform
	tDrive(127,127,2000);//drive to center

}*/

/*void AutoA(int direction){//Skills Auto near flags 2 Point Red anb Blue
tDrive(100,90,1100);//drive to cap
motor[cap_flip_left] = -80;//flip cap
wait1Msec(700);
motor[cap_flip_left]=0;//turn off cap motor
tDrive(-70,-70,1200);//reverse to flag
tDrive(-100 *direction ,100 * direction, 340);//turn to flag
tDrive(-100,-100,1500);//reverse to toggle flag
tDrive(100,100,300);//pull forward
}*/








/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              Autonomous Task                              */
/*                                                                           */
/*  This task is used to control your robot during the autonomous phase of   */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/
/*task autonomous(){
if(SensorValue[red_blue_sw] <2000){
AutoA(1);}
else{AutoA(-1);}
}*/


task autonomous(){
	if(SensorValue[red_blue_sw] <2000){
		autoB(1);}
	else{autoB(-1);}
}

// ..........................................................................
// Insert user code here.
// ..........................................................................



/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              User Control Task                            */
/*                                                                           */
/*  This task is used to control your robot during the user control phase of */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/
task usercontrol(){
	//set-up tasks, sensors etc..
	resetMotorEncoder(drive_left_front);
	resetMotorEncoder(drive_right_front);
	startTask(drive);
	startTask(arm);
	startTask(poleLift);
	startTask(autoFC);
	startTask(FlipFrame);

	while (true){


		/*	MICRO-DRIVE */
		if(vexRT[Btn8U]==1){//straight
			stopTask(drive);
			tDrive(30,30,300);
			startTask(drive);}
		if(vexRT[Btn8D]==1){	//reverse
			stopTask(drive);
			tDrive(-30,-30,300);
			startTask(drive);}
		if(vexRT[Btn8L]==1){	//left
			stopTask(drive);
			tDrive(-30,30,300);
			startTask(drive);}
		if(vexRT[Btn8R]==1){	//right
			stopTask(drive);
			tDrive(30,-30,300);
			startTask(drive);}



		/* ROBOT-LIFT FOR PARKING  */

		if(vexRT[Btn7U]==1){
			stopTask(arm);
			while(SensorValue(robot_lift_angle)> ROBOT_LIFT_UP){
				motor[robot_lift]=90;}
			startTask(arm);}

		if(vexRT[Btn7D]==1){
			stopTask(arm);
			while(SensorValue(robot_lift_angle)<ROBOT_LIFT_DOWN){
				motor[robot_lift]=-90;}
			startTask(arm);
		}
		if(SensorValue(robot_lift_angle)>2500){
			motor[robot_lift]=-15;}

		//end while
		else{
			motor[robot_lift]=0;}
		}


}//end main
