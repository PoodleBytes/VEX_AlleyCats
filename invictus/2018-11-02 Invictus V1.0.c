#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    launch_angle,   sensorPotentiometer)
#pragma config(Sensor, in2,    auto_select,    sensorPotentiometer)
#pragma config(Sensor, in3,    lift_angle,     sensorPotentiometer)
#pragma config(Sensor, I2C_1,  encoder_left_drive, sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  encoder_right_drive, sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           launch_ball,   tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           drive_right,   tmotorVex393_MC29, openLoop, reversed, driveLeft, encoderPort, I2C_2)
#pragma config(Motor,  port3,           drive_left,    tmotorVex393_MC29, openLoop, driveRight, encoderPort, I2C_1)
#pragma config(Motor,  port4,           lift_left,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           lift_right,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           flip_motor,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           claw_lift,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           claw,          tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           ball_pickup,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          launch_height, tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*		VEX COMPETITION TEMPLATE		*/
#pragma platform(VEX2)
//#pragma competitionControl(Competition)	//don't think we need this but leave just in case
#include "Vex_Competition_Includes.c"

void pre_auton()		//CODE TO RUN BEFORE ANYTHING
{
	slaveMotor(lift_right, lift_left);	//lift_right will do whatever lift_left does
  bStopTasksBetweenModes = true;	//stop any task started in autonomous?
}
/*		END VEX COMPETITION TEMPLATE		*/

/* 		VARIABLES		*/
//drive(
int L_POWER = 20;								//left drive power in drive()
int R_POWER = 20;								//right drive power in drive()
int MAX_POWER = 100;						//maximum power to motor - 127 is max
float DRIVE_SENSITIVITY = 1.0;		//coefficient = decrease joystick sensitivity
int DEADBAND = 0;							//Joystick seldom 0 when off so this is the value to ignore joystick 'noise' below

//lift()
int LIFT_UP = 85;				//power to raise lift
int LIFT_DOWN = -100;		//lower lift
int LIFT_HOLD =-5;			//power to hold lift

//flip
int MOTOR_FLIP_TIME = 200;	//time to flip_motor 360 degrees
int HOLD_MOTOR_FLIP =0;	//power to hold motor_flip
int CLAW_FLIP_TIME	= 200;	//time to flip claw 180 degrees
int HOLD_CLAW_FLIP = 0;	//power to hold claw_flip

//ball launch
int BALL_LAUNCH = 20000;	//mS to run ball_pickup
int LAUNCH_HOLD = 15;	//power to hold launch angle
int FLAG_A = 1500;	//launch_angle value for flag position A
int FLAG_B = 3000;	//launch_angle value for flag position A

// autonomous driving variables
int DRIVE_PAUSE = 200;
int BRAKE_TIME = 50;

/* END VARIABLES */

/* TASKS and FUNCTIONS 	*/

task drive(){
	while(true){
		if(abs(vexRT[Ch2]) > DEADBAND){
			R_POWER = vexRT[Ch3] * DRIVE_SENSITIVITY;
		}
		else {
			R_POWER = 0;
		}

		if(abs(vexRT[Ch3]) > DEADBAND){
			L_POWER = vexRT[Ch2] * DRIVE_SENSITIVITY;
		}
		else {
			L_POWER = 0;
		}

		// limit motor power to MAX_POWER
		if(abs(R_POWER) > MAX_POWER)
			R_POWER = sgn(R_POWER) * MAX_POWER;
		if(abs(L_POWER) > MAX_POWER )
			L_POWER = sgn(L_POWER) * MAX_POWER;

		motor[driveLeft]= L_POWER;
		motor[driveRight]=R_POWER;
	}//end while
}//end task drive

task lift(){
	while(true){
		if(vexRT[Btn6U]==1){
			motor[lift_left]=LIFT_UP;
		}
		else if(vexRT[Btn6D]==1){
			motor[lift_left]=LIFT_DOWN ;
		}
		else{
			motor[lift_left]=LIFT_HOLD;
		}
	}//end
}//end arm

//	DRIVE BASED ON ENCODER 'TICKS'
void eDrive(int l, int r, int e){
	//reset encoders
	resetMotorEncoder(drive_right);
	resetMotorEncoder(drive_left);

	//drive & brake
	wait1Msec(DRIVE_PAUSE);		//brief pause
	while(abs(getMotorEncoder(drive_right)) < e)  {		//drive until encoder 'ticks' = e
		motor[drive_right]=r;
		motor[drive_left]=l;}
	wait1Msec(BRAKE_TIME);
	motor[drive_right]=0;		//shut motors off
	motor[drive_left]=0;
	wait1Msec(BRAKE_TIME);
	motor[drive_right]=r *-.5;	//briefly reversing motors acts like a brake
	motor[drive_left]=l * -.5;
	wait1Msec(BRAKE_TIME/2);					//shut motors off
	motor[drive_right]=0;
	motor[drive_left]=0;
}//end eDrive

//TIMED DRIVE
void tDrive(int l, int r, int t){
	wait1Msec(DRIVE_PAUSE);
	motor[drive_right]=r;
	motor[drive_left]=l;
	wait1Msec(t);
	motor[drive_right]=0;
	motor[drive_left]=0;
	wait1Msec(BRAKE_TIME);
	motor[drive_right]=r *-.5;
	motor[drive_left]=l * -.5;
	wait1Msec(BRAKE_TIME/2);
	motor[drive_right]=0;
	motor[drive_left]=0;
}//end tDrive

void flipMotor(int dir){
	motor[flip_motor]=50 * dir;
	wait1Msec(MOTOR_FLIP_TIME);
	motor[flip_motor]=0;
	wait1Msec(BRAKE_TIME);
	motor[flip_motor]=-10 * dir;
	wait1Msec(BRAKE_TIME/2);
	motor[flip_motor]=HOLD_MOTOR_FLIP;
}//end flipMotor

void flipClaw(int dir,int t){
	motor[claw_lift]=50 * dir;
	wait1Msec(t);
	motor[claw_lift]=0;
	wait1Msec(BRAKE_TIME);
	motor[claw_lift]=-10 * dir;
	wait1Msec(BRAKE_TIME/2);
	motor[claw_lift]=HOLD_CLAW_FLIP;
}//end flipMotor

void autoA(int dir){
		// TEST ONLY!!!
		tDrive(50,50,2000);	//drive forward 2s
		tDrive(-50 * dir, 50 * dir, 1500);//turn
		eDrive(-50,-50,2000);	//test encoder equiv for 2 seconds forward
		eDrive(-50 * dir, 50 * dir, 1500);//turn
	}//end autoA

/* END TASKS and FUNCTIONS */

task autonomous()
{
	//level claw
	flipClaw(1, CLAW_FLIP_TIME/2);

	if(SensorValue(auto_select)<2000){
		autoA(1);}	//position A
	else{autoA(-1);}//mirror of position A
}


task usercontrol()	//replaces main() function in you code
{
startTask(drive);
startTask(lift);

  while (true)
  {
   	if(vexRT(Btn7U)==1){	//launch_ball
   		motor[launch_ball]=100;
   	}

   	if(vexRT(Btn8L)==1){	//flip motor fwd
   		flipMotor(1);
   	}
  	else if(vexRT(Btn8R)==1){	//flip motor back
   		flipMotor(-1);
   	}

   	if(vexRT(Btn5U)==1)//flip claw fwd
   		motor[claw_lift]=90;
  	else if(vexRT(Btn5D)==1)	//flip claw back
   		motor[claw_lift]=-90;
   	else
   		motor[claw_lift]=0;
   {

	if(vexRT(Btn7D)==1){	//run ball motor for BALL_LANUCH mSeconds
   		motor[ball_pickup] = 100;
   		wait1Msec(BALL_LAUNCH);
   		motor[ball_pickup] = 0;
   	}

  	if(vexRT(Btn8D)==1){	//open claw
   		motor[claw]=-80;
   		wait1Msec(500);
   		motor[claw]=0;
   	}
   	
	if(vexRT(Btn8U)==1){	//close & hold claw
   		motor[claw]=80;
   		wait1Msec(500);
   		motor[claw]=25;
   		motor[claw_lift]=20;
   		motor[lift_left]=20;
   		motor[lift_right]=20;
   	}

   	// !!!!!! NEED TO CONFIRM POTENTIONMETER VALUES / DIRECTION  !!!
 	if(vexRT(Btn7L)==1){	//aim arm for flag  A
   		if(SensorValue(launch_angle) < FLAG_A) //raise arm because it is lower than intended angle
					while(SensorValue(launch_angle) < FLAG_A){
						motor[launch_height]=60;}
					motor[launch_height] = LAUNCH_HOLD;}
			else if(SensorValue(launch_angle) > FLAG_A) //lower arm because it is higher than intended angle
					while(SensorValue(launch_angle) > FLAG_A){
						motor[launch_height]=-20;}	//lower arm because it is lower than intended angle
					motor[launch_height] = LAUNCH_HOLD;
			}

   	if(vexRT(Btn7R)==1){//aim arm for flag B
   		if(SensorValue(launch_angle) < FLAG_B) //raise arm because it is lower than intended angle
					while(SensorValue(launch_angle) < FLAG_B){
						motor[launch_height]=60;}
					motor[launch_height] = LAUNCH_HOLD;}
			else if(SensorValue(launch_angle) > FLAG_B) //raise arm because it is lower than intended angle
					while(SensorValue(launch_angle) > FLAG_B){
						motor[launch_height]=-20;}	//lower arm because it is lower than intended angle
					motor[launch_height] = LAUNCH_HOLD;
				}
}